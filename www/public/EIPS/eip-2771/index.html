<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8" />
        <meta http-equiv="X-UA-Compatible" content="IE=edge" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <link rel="stylesheet" href="https:&#x2F;&#x2F;eips.ethereum.com&#x2F;minima.css">

        <!-- opengraph -->
        <meta property="og:locale" content="en_US" />
        <meta property="og:url" content="https:&#x2F;&#x2F;eips.ethereum.com" />
        <meta property="og:site_name" content="Ethereum Improvement Proposals" />

        <!-- twitter -->
        <meta name="twitter:card" content="summary" />
        <meta name="twitter:site" content="@ethereum" />

        <script type="application/ld+json">
            {
              "@type": "WebSite",
              "url": "https:&#x2F;&#x2F;eips.ethereum.com",
              "name": "Ethereum Improvement Proposals",
              "description": "Description",
              "@context": "https://schema.org"
            }
        </script>

        

        

<title>EIP-2771: Secure Protocol for Native Meta Transactions</title>
<link rel="canonical" href="https:&#x2F;&#x2F;eips.ethereum.comEIPS&#x2F;eip-2771.md" />
<meta property="og:title" content="EIP-2771: Secure Protocol for Native Meta Transactions" />
<meta
    name="description"
    content="Details on Ethereum Improvement Proposal 2771 (EIP-2771): Secure Protocol for Native Meta Transactions"
/>
<meta
    property="og:description"
    content="Details on Ethereum Improvement Proposal 2771 (EIP-2771): Secure Protocol for Native Meta Transactions"
/>
<meta property="og:url" content="https:&#x2F;&#x2F;eips.ethereum.comEIPS&#x2F;eip-2771.md" />
<meta name="twitter:description" content="Details on Ethereum Improvement Proposal 2771 (EIP 2771): Secure Protocol for Native Meta Transactions" />

    </head>
    <body>
        <header class="site-header">
            <div class="wrapper">
                <a class="site-title" rel="author" href="https:&#x2F;&#x2F;eips.ethereum.com">Ethereum Improvement Proposals</a>
                <nav class="site-nav">
                    <input type="checkbox" id="nav-trigger" class="nav-trigger" />
                    <label for="nav-trigger">
                        <span class="menu-icon">
                            <svg viewBox="0 0 18 15" width="18px" height="15px">
                                <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
                            </svg>
                        </span>
                    </label>

                    <div class="trigger">
                        
                            <a class="page-link" href="&#x2F;all">All</a>
                        
                            <a class="page-link" href="&#x2F;core">Core</a>
                        
                            <a class="page-link" href="&#x2F;networking">Networking</a>
                        
                            <a class="page-link" href="&#x2F;interface">Interface</a>
                        
                            <a class="page-link" href="&#x2F;erc">ERC</a>
                        
                            <a class="page-link" href="&#x2F;meta">Meta</a>
                        
                            <a class="page-link" href="&#x2F;informational">Informational</a>
                        
                    </div>
                </nav>
            </div>
        </header>
        <main class="page-content" aria-label="Content">
            <div class="wrapper">
                
<div class="home">
    <h1 class="page-heading">
        EIP-2771: Secure Protocol for Native Meta Transactions
        <a href=""><svg role="img" aria-label="Source" xmlns="https://www.w3.org/2000/svg" width="14" height="16" viewBox="0 0 14 16"><title>Source</title><path fill-rule="evenodd" d="M9.5 3L8 4.5 11.5 8 8 11.5 9.5 13 14 8 9.5 3zm-5 0L0 8l4.5 5L6 11.5 2.5 8 6 4.5 4.5 3z"/></svg></a>
    </h1>
    <table>
        <tr>
            <th>Author</th>
            <td>
    
        
        
            <a href="https://github.com/wighawag">Ronan Sandford</a>,
        
    
        
        
            <a href="https://github.com/lirazsiri"> Liraz Siri</a>,
        
    
        
        
            <a href="https://github.com/drortirosh"> Dror Tirosh</a>,
        
    
        
        
            <a href="https://github.com/yoavw"> Yoav Weiss</a>,
        
    
        
        
            <a href="https://github.com/forshtat"> Alex Forshtat</a>,
        
    
        
        
            <a href="https://github.com/Amxx"> Hadrien Croubois</a>,
        
    
        
        
            <a href="https://github.com/tomarsachin2271"> Tomar Sachin</a>,
        
    
        
        
            <a href="https://github.com/stonecoldpat"> Patrick McCorry</a>,
        
    
        
        
            <a href="https://github.com/nventuro"> Nicolas Venturo</a>,
        
    
        
        
            <a href="https://github.com/frozeman"> Fabian Vogelsteller</a>
        
    
</td>
        </tr>

        
          <tr>
              <th>Discussions-To</th>
              <td><a href="https:&#x2F;&#x2F;ethereum-magicians.org&#x2F;t&#x2F;eip-2771-secure-protocol-for-native-meta-transactions">https:&#x2F;&#x2F;ethereum-magicians.org&#x2F;t&#x2F;eip-2771-secure-protocol-for-native-meta-transactions</a></td>
          </tr>
        

        <tr>
            <th>Status</th>
            <td>
                Draft
                
            </td>
        </tr>

        <tr>
            <th>Type</th>
            <td>Standards Track</td>
        </tr>

        
          <tr>
              <th>Category</th>
              <td>ERC</td>
          </tr>
        

        <tr>
            <th>Created</th>
            <td>2020-07-01</td>
        </tr>

        

        

        

        

        
  </table>

  
    <h2 id="simple-summary">Simple Summary</h2>
<p>A contract interface for receiving meta transactions through a trusted
forwarder.</p>
<h2 id="abstract">Abstract</h2>
<p>This ERC defines a minimal contract-level protocol that a compliant Recipient
contract needs to support in order to be capable of accepting a meta
transaction through a compliant Forwarder contract that it trusts to help it
identify the address of the Transaction Signer. </p>
<p>No EVM-level protocol changes are proposed or required.</p>
<h2 id="motivation">Motivation</h2>
<p>There is a growing interest in making it possible for Ethereum contracts to
accept calls from externally owned accounts that do not have ETH to pay for
gas. </p>
<p>This can be accomplished with meta transactions, which are transactions that
have been:</p>
<ol>
<li>Authorized by the <strong>Transaction Signer</strong>. For example, signed by an
externally owned account.</li>
<li>Relayed by an untrusted third party that pays for the gas (the <strong>Gas
Relay</strong>)</li>
</ol>
<p><code>msg.sender</code> is a transaction parameter that can be inspected by a contract to
determine who signed the transaction. The integrity of this parameter is
guaranteed by the Ethereum EVM, but for a meta transaction securing
<code>msg.sender</code> is insufficient.</p>
<p>The problem is that for a contract that is not natively aware of meta
transactions, the <code>msg.sender</code> of the transaction will make it appear to be
coming from the <strong>Gas Relay</strong> and not the <strong>Transaction Signer</strong>. A secure
protocol for a contract to accept meta transactions needs to prevent the <strong>Gas
Relay</strong> from forging, modifying or duplicating requests by the <strong>Transaction
Signer</strong>.</p>
<h2 id="specification">Specification</h2>
<p>The keywords &quot;MUST&quot;, &quot;MUST NOT&quot;, &quot;REQUIRED&quot;, &quot;SHALL&quot;, &quot;SHALL NOT&quot;, &quot;SHOULD&quot;,
&quot;SHOULD NOT&quot;, &quot;RECOMMENDED&quot;, &quot;MAY&quot;, and &quot;OPTIONAL&quot; in this document are to be
interpreted as described in <a href="https://www.ietf.org/rfc/rfc2119.txt">RFC 2119</a>).</p>
<p>Here is an example flow:</p>
<p><img src="../assets/eip-2771/example-flow.png" alt="Example flow" /></p>
<ul>
<li><strong>Transaction Signer</strong> - entity that signs &amp; sends to request to <strong>Gas
Relay</strong></li>
<li><strong>Gas Relay</strong> - receives a signed request off-chain from <strong>Transaction
Signer</strong> and pays gas to turn it into a valid transaction that goes through
<strong>Trusted Forwarder</strong></li>
<li><strong>Trusted Forwarder</strong> - a contract that is trusted by the <code>Recipient</code> to
correctly verify the signature and nonce before forwarding the request from
<strong>Transaction Signer</strong></li>
<li><strong>Recipient</strong> - a contract that can securely accept meta-transactions
through a <strong>Trusted Forwarder</strong> by being compliant with this standard.</li>
</ul>
<h3 id="extracting-the-transaction-signer-address">Extracting The Transaction Signer address</h3>
<p>The <strong>Trusted Forwarder</strong> is responsible for calling the <strong>Recipient</strong> contract
and MUST append the address of the <strong>Transaction Signer</strong> (20 bytes of data) to
the end of the call data.</p>
<p>For example :</p>
<pre style="background-color:#2b303b;">
<code><span style="color:#c0c5ce;">(bool success, bytes memory returnData) = to.call.value(value)(abi.encodePacked(data, from));
</span></code></pre>
<p>The <strong>Recipient</strong> contract can then extract the <strong>Transaction Signer</strong> address
by performing 3 operations:</p>
<ol>
<li>Check that the <strong>Forwarder</strong> is trusted. How this is implemented is out of
the scope of this proposal.</li>
<li>Extract the <strong>Transaction Signer</strong> address from the last 20 bytes of the
call data and use that as the original <code>sender</code> of the transaction (instead of <code>msg.sender</code>)</li>
<li>If the <code>msg.sender</code> is not a trusted forwarder (or if the msg.data is
shorter than 20 bytes), then return the original <code>msg.sender</code> as it is.</li>
</ol>
<p>The <strong>Recipient</strong> MUST check that it trusts the Forwarder to prevent it from
extracting address data appended from an untrusted contract. This could result
in a forged address.</p>
<h3 id="protocol-support-discovery-mechanism">Protocol Support Discovery Mechanism</h3>
<p>Unless a <strong>Recipient</strong> contract is being used by a particular frontend that
knows that this contract has support for native meta transactions, it would not
be possible to offer the user the choice of using meta-transaction to interact
with the contract. We thus need a mechanism by which the <strong>Recipient</strong> can let
the world know that it supports meta transactions. </p>
<p>This is especially important for meta transactions to be supported at the Web3
wallet level. Such wallets may not necessarily know anything about the
<strong>Recipient</strong> contract users may wish to interact with.</p>
<p>As a <strong>Recipient</strong> could trust forwarders with different interfaces and
capabilities (e.g., transaction batching, different message signing formats),
we need to allow wallets to discover which Forwarder is trusted.</p>
<p>To provide this discovery mechanism a <strong>Recipient</strong> contract MUST implement
this function:</p>
<pre style="background-color:#2b303b;">
<code><span style="color:#c0c5ce;">function isTrustedForwarder(address forwarder) external returns(bool);
</span></code></pre>
<ul>
<li>That function MUST return true if the forwarder is trusted by the
Recipient.</li>
<li>That function MUST return false if the forwarder is not trusted.</li>
<li>That function MUST NOT throw a revert.</li>
</ul>
<p>Internally, the <strong>Recipient</strong> MUST then accept a request from forwarder</p>
<p>That function can be called on-chain and as such gas restriction needs to be
put in place. </p>
<p>A Gas limit of 10k is enough for making  the decision either inside the
contract, or delegating it to another contract and doing some memory access
calculations, like querying a mapping.</p>
<h3 id="recipient-example">Recipient example</h3>
<pre style="background-color:#2b303b;">
<code><span style="color:#c0c5ce;">contract RecipientExample {

    function purchaseItem(uint256 itemId) external {
        address sender = _msgSender();
        ... perform the purchase for sender
    }

    address immutable _trustedForwarder;
    constructor(address trustedForwarder) internal {
        _trustedForwarder = trustedForwarder;
    }

    function isTrustedForwarder(address forwarder) external returns(bool) {
        return forwarder == _trustedForwarder;
    }

    function _msgSender() internal view returns (address payable signer) {
        signer = msg.sender;
        if (isTrustedForwarder(signer)) {
            bytes memory data = msg.data;
            uint256 length = msg.data.length;
            assembly { signer := mload(add(data, length))) }
        }    
    }

}
</span></code></pre><h2 id="rationale">Rationale</h2>
<ul>
<li>
<p>Make it easy for contract developers to add support for meta
transactions by standardizing the simplest viable contract interface.</p>
</li>
<li>
<p>Without support for meta transactions in the recipient contract, an externally owned 
account can not use meta transactions to interact with the recipient contract.</p>
</li>
<li>
<p>Without a standard contract interface, there is no standard way for a client
to discover whether a recipient supports meta transactions.</p>
</li>
<li>
<p>Without a standard contract interface, there is no standard way to send a
meta transaction to a recipient.</p>
</li>
<li>
<p>Without the ability to leverage a trusted forwarder every recipient contract
has to internally implement the logic required to accept meta transactions securely.</p>
</li>
<li>
<p>Without a discovery protocol, there is no mechanism for a client to discover
whether a recipient supports a specific forwarder.</p>
</li>
<li>
<p>Making the contract interface agnostic to the internal implementation
details of the trusted forwarder, makes it possible for a recipient contract
to support multiple forwarders with no change to code.</p>
</li>
</ul>
<h2 id="security-considerations">Security Considerations</h2>
<p>A bad forwarder may allow forgery of the <code>msg.sender</code> returned from
<code>_msgSender()</code> and allow transactions to appear to be coming from any address. </p>
<p>This means a recipient contract should be very careful which forwarder it
trusts and whether this can be modified. The power to change the forwarder
trusted by a recipient is equivalent to giving full control over the contract.
If this kind of control over the recipient is acceptable, it is recommended
that only the owner of the recipient contract be able to modify which forwarder
is trusted. Otherwise best to leave it unmodifiable, as in the example above.</p>
<h2 id="implementations">Implementations</h2>
<p>An implementation of a base class for a recipient: <a href="https://github.com/opengsn/forwarder/blob/master/contracts/BaseRelayRecipient.sol">BaseRelayRecipient.sol</a></p>
<h2 id="copyright">Copyright</h2>
<p>Copyright and related rights waived via
<a href="https://creativecommons.org/publicdomain/zero/1.0/">CC0</a>.</p>



            </div>
        </main>


        <footer class="site-footer h-card">
            <div class="wrapper">
                <h2 class="footer-heading">Ethereum Improvement Proposals</h2>
                <div class="footer-col-wrapper">
                    <div class="footer-col footer-col-1">
                        <ul class="contact-list">
                            <li class="p-name">
                                
                                GitHub User
                                
                            </li>
                            <li>
                                <a class="u-email" href="mailto:your-email@domain.com">
                                  your-email@domain.com
                                </a>
                              </li>
                            </ul>
                    </div>
                    <div class="footer-col footer-col-3">
                        <p>Description</p>
                    </div>
                </div>
            </div>
        </footer>
    </body>
</html>
